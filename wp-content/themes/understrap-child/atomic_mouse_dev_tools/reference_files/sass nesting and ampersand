.proof__item_container{
    @include make-col-ready();
    @include make-col(4);
    padding-left: 0px;
    padding-right: 0px;
&,&.one{
    background: red;
}
&,&.two{
    background: green;
}
}

//above results in 
.proof__item_container{
    @include make-col-ready();
    @include make-col(4);
    padding-left: 0px;
    padding-right: 0px;	
}

.proof__item_container.one {
background: red;
}
.proof__item_container.two{
	background: green;
}

/////////////////////
&.class
.some-class.another-class { }
You can do this while nesting by using the &.

.some-class {
  &.another-class {}
}

//////////////////////////
& .class 
.parent {
  .child {}
}
This can actually be thought of as short-hand for nesting with the &:

.parent {
  & .child {}
}
So, these two examples both compile to the same thing:

.parent .child {}

/////////////////////////
Using the & with the child combinator >, adjacent sibling combinator +, and the general sibling combinator ~ is a breeze. At first I thought you had to use the &, but:

// You don't actually have to do this.
// Here, the ampersand is implied.
.button {
  & > span { }
  & + span { }
  & ~ span { }
}
Leaving the &'s out of the selector works here:

// This compiles the same as above
.button {
  > span { }
  + span { }
  ~ span { }
}
Both of these examples compile into this CSS:

.button > span { }
.button + span { }
.button ~ span { }

//////////////////////
Qualifying based on context
Nested selectors don't necessarily have to start with the ampersand. You can qualify a selector by putting the & on the right.

.button {
  body.page-about & { }
}
We're repositioning the parent selector exactly where we need it. This is really useful for qualifying a selector based on a different parent. This will compile to:

body.page-about .button {}
Meaning, select the button class only when a child of a body with a page-about class.

////////////////////////////////////////



t's worth mentioning that @at-root allows you to break out of your nesting structure entirely to the "root" of your nesting tree.

.grand-parent {
  .parent {
    @at-root .child {}
  }
}
We've teleported out of the nesting tree to this compiled CSS:

.child {}
This is nice. From an organizational perspective, all the code is still grouped together, which could be noted as an unsung benefit of nesting. @at-root can help keep specificity levels low because you no longer have the compiled parent selector to increase specificity. All the while still keeping your code conceptually organized with nesting:

.grand-parent {
  .parent {
    @at-root body.page-about .child {}
  }
}
Compiled CSS:

body.page-about .child {}

///////////////////////////////////////////////
Sometimes you need to beat-down the specificity of a 3rd-party CSS library to take ownership of the style:

.parent.parent {}
It's a lot less overpowering than using and ID, inline style, or !important and it could have benefits over qualifying the selector with an arbitrary parent element. The specificity level isn't raised based on a selector's context, but only by itself. With the & you can do that same thing like this.

.parent {
  &#{&} { }
}
The interpolation brackets #{ } are needed as two touching ampersands are invalid Sass.



///////////////////////////////////////////

Modifying the ampersand
Even though you can't have two ampersands touching without the interpolation brackets — as we demoed earlier in our pseudo class example — you can have another selector touch the ampersand. Touching the ampersand works well with modifier classes.

.btn {
  &-primary {}
  &-secondary {}
}
Compiled CSS:

.btn-primary {}
.btn-secondary {}
This can be quite useful if employing a naming methodology (i.e. BEM) which uses dash and underscore combinated classes rather than combined selectors.






/////////////////////////////////////
"#header .callout":

Select all elements with the class name callout that are decendents of the element with an ID of header.

#header.callout":

Select the element which has an ID of header and also a class name of callout.


#.container div
"Select any div element that is a child of any element with a class name of "container"

#div.container
"Select any div element that has a class name of "container"



Descendant Selector
The descendant selector matches all elements that are descendants of a specified element.

The following example selects all <p> elements inside <div> elements: 

Example
div p {
  background-color: yellow;
}




Child Selector
The child selector selects all elements that are the immediate children of a specified element.

The following example selects all <p> elements that are immediate children of a <div> element:

Example
div > p {
  background-color: yellow;
}


Adjacent Sibling Selector
The adjacent sibling selector selects all elements that are the adjacent siblings of a specified element.

Sibling elements must have the same parent element, and "adjacent" means "immediately following".

The following example selects all <p> elements that are placed immediately after <div> elements:

Example
div + p {
  background-color: yellow;
}



General Sibling Selector
The general sibling selector selects all elements that are siblings of a specified element.

The following example selects all <p> elements that are siblings of <div> elements: 

Example
div ~ p {
  background-color: yellow;
}